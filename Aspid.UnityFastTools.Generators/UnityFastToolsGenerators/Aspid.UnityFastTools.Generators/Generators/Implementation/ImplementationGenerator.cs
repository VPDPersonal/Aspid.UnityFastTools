using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Aspid.Generators.Helper;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace UnityFastToolsGenerators.Generator.Implementation;

[Generator(LanguageNames.CSharp)]
public class ImplementationGenerator : IIncrementalGenerator
{
    public static readonly TypeText ImplementationAttribute =
        new(nameof(ImplementationAttribute), new NamespaceText("Aspid.UnityFastTools"));

    private readonly struct ImplData
    {
        public ImplData(INamedTypeSymbol target, INamedTypeSymbol impl)
        {
            Target = target;
            Impl = impl;
        }
        public INamedTypeSymbol Target { get; }
        public INamedTypeSymbol Impl { get; }
    }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(Predicate, Transform)
            .Where(static foundForGenerator => foundForGenerator.HasValue)
            .Select(static (foundForGenerator, _) => foundForGenerator!.Value);

        context.RegisterSourceOutput(provider, GenerateCode);
    }

    private static bool Predicate(SyntaxNode node, CancellationToken cancellationToken) =>
        node is TypeDeclarationSyntax candidate && candidate.Modifiers.Any(SyntaxKind.PartialKeyword);

    private static ImplData? Transform(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        if (context.Node is not TypeDeclarationSyntax tds)
            return default;
        var targetSymbol = context.SemanticModel.GetDeclaredSymbol(tds, cancellationToken) as INamedTypeSymbol;
        if (targetSymbol is null)
            return default;

        // Look through attributes applied to the target type and find any whose class derives from ImplementationAttribute
        var attrClass = targetSymbol.GetAttributes()
            .Select(a => a.AttributeClass)
            .FirstOrDefault(a => DerivesFromImplementationAttribute(a));
        if (attrClass is null)
            return default;

        // In the attribute class, find a nested class that derives from base Implementation
        var implType = attrClass
            .GetTypeMembers()
            .FirstOrDefault(t => InheritsFromNestedImplementation(t));

        if (implType is null)
            return default;

        return new ImplData(targetSymbol, implType);

        static bool DerivesFromImplementationAttribute(INamedTypeSymbol? type)
        {
            while (type != null)
            {
                var name = type.ToDisplayString();
                if (name == ImplementationAttribute.FullName) return true;
                type = type.BaseType;
            }
            return false;
        }

        static bool InheritsFromNestedImplementation(INamedTypeSymbol type)
        {
            var baseType = type.BaseType;
            while (baseType != null)
            {
                // Check that base is a nested type named Implementation within Aspid.UnityFastTools.ImplementationAttribute
                if (baseType.Name == "Implementation" &&
                    baseType.ContainingType is { Name: "ImplementationAttribute" } ct &&
                    ct.ContainingNamespace?.ToDisplayString() == "Aspid.UnityFastTools")
                    return true;
                baseType = baseType.BaseType;
            }
            return false;
        }
    }

    private static void GenerateCode(SourceProductionContext context, ImplData data)
    {
        var target = data.Target;
        var impl = data.Impl;

        var ns = target.ContainingNamespace?.IsGlobalNamespace == false
            ? target.ContainingNamespace.ToDisplayString()
            : null;
        var typeKind = target.TypeKind == TypeKind.Struct ? "struct" : "class";
        var name = target.Name;

        // Collect members from impl
        var fields = impl.GetMembers().OfType<IFieldSymbol>().Where(f => f.DeclaredAccessibility != Accessibility.Private);
        var properties = impl.GetMembers().OfType<IPropertySymbol>().Where(p => p.DeclaredAccessibility != Accessibility.Private);

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated>");
        if (!string.IsNullOrEmpty(ns))
        {
            sb.Append("namespace ").Append(ns).AppendLine();
            sb.AppendLine("{");
        }

        // Use the same declared accessibility and modifiers as target requires partial
        var modifiers = GetTypeModifiers(target);
        sb.Append(modifiers).Append(' ').Append(typeKind).Append(' ').Append(name);
        AppendTypeParameters(sb, target);
        sb.AppendLine();
        sb.AppendLine("{");

        foreach (var f in fields)
        {
            sb.Append("    ")
              .Append(GetAccessibility(f.DeclaredAccessibility))
              .Append(' ')
              .Append(TypeToDisplay(f.Type))
              .Append(' ')
              .Append(f.Name)
              .AppendLine(";");
        }

        foreach (var p in properties)
        {
            sb.Append("    ")
              .Append(GetAccessibility(p.DeclaredAccessibility))
              .Append(' ')
              .Append(TypeToDisplay(p.Type))
              .Append(' ')
              .Append(p.Name)
              .Append(" { ");

            if (p.GetMethod != null)
            {
                if (p.GetMethod.DeclaredAccessibility != p.DeclaredAccessibility)
                {
                    sb.Append(GetAccessibility(p.GetMethod.DeclaredAccessibility)).Append(' ');
                }
                sb.Append("get; ");
            }
            if (p.SetMethod != null)
            {
                if (p.SetMethod.DeclaredAccessibility != p.DeclaredAccessibility)
                {
                    sb.Append(GetAccessibility(p.SetMethod.DeclaredAccessibility)).Append(' ');
                }
                sb.Append("set; ");
            }

            sb.AppendLine("}");
        }

        // Methods from impl
        var methods = impl.GetMembers().OfType<IMethodSymbol>()
            .Where(m => m.MethodKind == MethodKind.Ordinary);

        foreach (var m in methods)
        {
            // For partial method definitions, emit partial signature without body
            if (m.IsPartialDefinition)
            {
                sb.Append("    ")
                  .Append("partial ")
                  .Append(TypeToDisplay(m.ReturnType)).Append(' ')
                  .Append(m.Name);

                AppendMethodTypeParameters(sb, m);
                AppendParameters(sb, m);
                AppendMethodConstraints(sb, m);
                sb.AppendLine(";");
                continue;
            }

            // Ordinary method: copy implementation body from attribute's nested Implementation
            sb.Append("    ")
              .Append(GetAccessibility(m.DeclaredAccessibility))
              .Append(m.IsStatic ? " static" : string.Empty)
              .Append(m.IsAsync ? " async" : string.Empty)
              .Append(' ')
              .Append(TypeToDisplay(m.ReturnType)).Append(' ')
              .Append(m.Name);

            AppendMethodTypeParameters(sb, m);
            AppendParameters(sb, m);
            AppendMethodConstraints(sb, m);

            var ct = context.CancellationToken;
            var synRef = m.DeclaringSyntaxReferences.FirstOrDefault();
            var methodSyntax = synRef?.GetSyntax(ct) as MethodDeclarationSyntax;
            if (methodSyntax?.ExpressionBody != null)
            {
                sb.Append(" => ")
                  .Append(methodSyntax.ExpressionBody.Expression.ToString())
                  .AppendLine(";");
            }
            else if (methodSyntax?.Body != null)
            {
                // Append the block body as-is
                sb.AppendLine();
                sb.Append(methodSyntax.Body.ToFullString());
            }
            else
            {
                // Fallback: keep a stub if body unavailable
                sb.AppendLine()
                  .AppendLine("    {")
                  .AppendLine("        throw new global::System.NotImplementedException();")
                  .AppendLine("    }");
            }
        }

        // Nested types from impl (classes, structs, interfaces, enums, records)
        foreach (var nested in impl.GetTypeMembers().Where(t => t.DeclaredAccessibility != Accessibility.Private))
        {
            var synRef = nested.DeclaringSyntaxReferences.FirstOrDefault();
            if (synRef == null) continue;
            if (synRef.GetSyntax(context.CancellationToken) is TypeDeclarationSyntax tds)
            {
                // Emit the nested type as-is within the target type, with one level indentation
                var text = tds.ToFullString();
                AppendIndented(sb, text, 1);
                sb.AppendLine();
            }
        }

        sb.AppendLine("}");
        if (!string.IsNullOrEmpty(ns)) sb.AppendLine("}");

        context.AddSource($"{target.Name}.Implementation.g.cs", sb.ToString());

        static string GetAccessibility(Accessibility a) => a switch
        {
            Accessibility.Public => "public",
            Accessibility.Internal => "internal",
            Accessibility.Protected => "protected",
            Accessibility.ProtectedOrInternal => "protected internal",
            Accessibility.Private => "private",
            _ => "public"
        };

        static string TypeToDisplay(ITypeSymbol t)
        {
            // Use minimally qualified name
            return t.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
        }

        static string GetTypeModifiers(INamedTypeSymbol symbol)
        {
            var sbm = new StringBuilder();
            sbm.Append(GetAccessibility(symbol.DeclaredAccessibility));
            sbm.Append(" partial");
            if (symbol.IsRecord) sbm.Append(" record");
            return sbm.ToString();
        }

        static void AppendTypeParameters(StringBuilder sbld, INamedTypeSymbol symbol)
        {
            if (symbol.TypeArguments.Length == 0) return;
            sbld.Append('<');
            for (int i = 0; i < symbol.TypeArguments.Length; i++)
            {
                if (i > 0) sbld.Append(',');
                sbld.Append(TypeToDisplay(symbol.TypeArguments[i]));
            }
            sbld.Append('>');
        }

        static void AppendIndented(StringBuilder sbld, string text, int indentLevels)
        {
            var indent = new string(' ', indentLevels * 4);
            using (var sr = new System.IO.StringReader(text))
            {
                string? line;
                while ((line = sr.ReadLine()) != null)
                {
                    sbld.Append(indent).AppendLine(line);
                }
            }
        }

        static void AppendMethodTypeParameters(StringBuilder sbld, IMethodSymbol method)
        {
            if (method.TypeParameters.Length == 0) return;
            sbld.Append('<');
            for (int i = 0; i < method.TypeParameters.Length; i++)
            {
                if (i > 0) sbld.Append(',');
                sbld.Append(method.TypeParameters[i].Name);
            }
            sbld.Append('>');
        }

        static void AppendParameters(StringBuilder sbld, IMethodSymbol method)
        {
            sbld.Append('(');
            for (int i = 0; i < method.Parameters.Length; i++)
            {
                if (i > 0) sbld.Append(", ");
                var p = method.Parameters[i];

                // modifiers
                if (p.RefKind == RefKind.Ref) sbld.Append("ref ");
                else if (p.RefKind == RefKind.Out) sbld.Append("out ");
                else if (p.RefKind == RefKind.In) sbld.Append("in ");
                if (p.IsParams) sbld.Append("params ");

                sbld.Append(TypeToDisplay(p.Type)).Append(' ').Append(p.Name);
            }
            sbld.Append(')');
        }

        static void AppendMethodConstraints(StringBuilder sbld, IMethodSymbol method)
        {
            if (method.TypeParameters.Length == 0) return;
            foreach (var tp in method.TypeParameters)
            {
                var any = false;
                var constraintSb = new StringBuilder();

                if (tp.HasReferenceTypeConstraint)
                {
                    if (any) constraintSb.Append(", ");
                    constraintSb.Append("class");
                    any = true;
                }
                if (tp.HasValueTypeConstraint)
                {
                    if (any) constraintSb.Append(", ");
                    constraintSb.Append("struct");
                    any = true;
                }
                if (tp.HasUnmanagedTypeConstraint)
                {
                    if (any) constraintSb.Append(", ");
                    constraintSb.Append("unmanaged");
                    any = true;
                }
                if (tp.HasNotNullConstraint)
                {
                    if (any) constraintSb.Append(", ");
                    constraintSb.Append("notnull");
                    any = true;
                }
                foreach (var ct in tp.ConstraintTypes)
                {
                    if (any) constraintSb.Append(", ");
                    constraintSb.Append(TypeToDisplay(ct));
                    any = true;
                }
                if (tp.HasConstructorConstraint)
                {
                    if (any) constraintSb.Append(", ");
                    constraintSb.Append("new()");
                    any = true;
                }

                if (any)
                {
                    sbld.Append(' ')
                        .Append("where ")
                        .Append(tp.Name)
                        .Append(" : ")
                        .Append(constraintSb);
                }
            }
        }
    }
}